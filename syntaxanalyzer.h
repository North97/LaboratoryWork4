#ifndef SYNTAXANALYZER_H
#define SYNTAXANALYZER_H

#include <vector>
#include <iostream>
#include <set>
#include <fstream>
#include <queue>
#include <sstream>

/**
    Класс, реализующий лексический анализатор посредством конечного автомата.

    Состояния конечного автомата (типы возможных лексем):
        0 - Символ разделитель
        1 - Идентификатор/ключевое слово
        2 - Числовая константа
        3 - Оператор присваивания
        4 - Разделитель операторов ;
        5 - Арифметические операции низкого приоритета +, -
        6 - Арифметические операции высокого приоритета *,\
        7 - Тип лексемы, не пренадлежащей данному языку

    Классы входных символов:
        0 - Символ разделитель
        1 - Десятичное число
        2 - Буква латинского алфавита
        3 - Символ оператора присваивания =
        4 - Символ разделителя операторов ;
        5 - Символ арифметической операции низкого приоритета +, -
        6 - Символ арифметической операции высокого приоритета *, \
        7 - Класс символов, не пренадлежащих данному языку

    Классы лексем:
        0 - Ключевое слово select
        1 - Ключевое слово case
        2 - Ключевое слово default
        3 - Ключевое слово end
        4 - Идентификатор
        5 - Числовая константа
        6 - Арифметическая операция
        7 - Оператор присваивания
        8 - Сепаратор ;
        9 - Неизвестная лексема
*/
class SyntaxAnalyzer
{
private:
    /**
        Детерменированный конечный автомат языка, реализованный в виде матрицы переходов.
    */
    std::vector<std::vector<int>> lexicalStateMachine = {
     //  0  1  2  3  4  5  6  7
        {0, 0, 0, 0, 0, 0, 0, 0}, // 0
        {2, 1, 2, 2, 2, 2, 2, 7}, // 1
        {1, 1, 7, 1, 1, 1, 1, 7}, // 2
        {3, 3, 3, 3, 3, 3, 3, 3}, // 3
        {4, 4, 4, 4, 4, 4, 4, 4}, // 4
        {5, 5, 5, 5, 5, 5, 5, 5}, // 5
        {6, 6, 6, 6, 6, 6, 6, 6}, // 6
        {7, 7, 7, 7, 7, 7, 7, 7}  // 7
    };

    std::vector<std::vector<int>> syntaxStateMachine = {
     //  0   1   2   3   4   5   6   7   8   9   10  11  12
        { 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 0
        {-1, -1,  3, -1, -1, -1, -1,  3, -1, -1, -1, -1, -1}, // 1
        {-1, -1, -1, -1, -1, -1, -1,  8, -1, -1, -1, -1, -1}, // 2
        {-1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, 12, -1}, // 3
        {-1,  2, -1, -1,  5, -1,  7, -1,  9, -1, 11, -1, -1}, // 4
        {-1,  2, -1,  4, -1, -1,  7, -1, -1, -1, 11, -1, -1}, // 5
        {-1, -1,  1, -1, -1, -1, -1,  6, -1, -1, -1, 10, -1}, // 6
        {-1, -1, -1, -1, -1,  6, -1, -1, -1, 10, -1, -1, -1}, // 7
        {-1, -1, -1, -1, -1, -1, -1,  4, -1, -1, -1,  8, -1}, // 8
        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}  // 9
    };

    /** Результирующий список лексем языка. */
    std::vector<std::string> resultLexeme;

    /** Результирующий список кодов лексем языка. */
    std::vector<int> codetLexeme;

    /** Сепараторы языка. */
    std::set<char> separators = {' ', '\n', '\t', '+', '-', ';', '*', '\\', '=', '\r'};

    /** Незначащие сепараторы языка. */
    std::set<char> insignSeparators = {' ', '\n', '\t', '\r'};

    /** Ключевые слова языка. */
    std::set<std::string> keywords = {"case", "select", "end", "default"};

    /** Метод, приводящий входной символ к определенному классу. */
    int toSymbolClass(char &);

    /** Метод возвращает класс лексемы. */
    int toLexemeClas(int &, std::string &);

    /** Определяет по состоянию, какая лексема ожидается */
    std::string expectedLexeme(int &);

public:
    SyntaxAnalyzer();

    /** Запуск алгоритма лексического анализатора. */
    void run(std::ifstream &);
};

#endif // SYNTAXANALYZER_H
